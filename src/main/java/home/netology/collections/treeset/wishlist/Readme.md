# Список покупок

*Описание*
Наверное, у каждого из нас есть списки желаемых покупок. Особенно перед праздниками.
Так давайте напишем программу для хранения этих "хотелок" так, чтобы они автоматически сортировались по какому-то признаку.

Что известно:
* Сущность "Хотелка": название (уникальное), краткое описание, цена, URL-адрес интернет-магазина или адрес магазина,
  приоритет (0 - 5, где 0 - очень низкий приоритет, а 5 - очень высокий приоритет).

### Функционал программы
1. Добавление "хотелок";
2. Сортировка по убыванию/возрастанию цены;
3. Сортировка по приоритету от самого важного до самого низкого приоритета.
4. Сортировка по наименованию

### Реализация
1. Создадим классы Wish. Рекомендую использовать следующие типы данных:
* Название — String;
* Краткое описание — String;
* Цена — double;
* URL-адрес интернет-магазина или адрес магазина — String;
* Приоритет — int.

2. Для того чтобы мы могли изменять тип сортировки, в процессе выполнения программы будем использовать интерфейс Comparator,
   а не Comparable. Если мы будем имплементировать интерфейс Comparable на уровне сущности Wish, мы будем привязаны к
   какому-то типу сортировки, в то же время мы можем просто передавать в конструктор TreeSet желаемый Comparator.
   Важно: в уже созданном объекте TreeSet нельзя менять тип сортировки.

3. Поэтому необходимо создать 2 класса, имплементирующих интерфейс Comparator<Wish> (один для сортировки по цене,
   второй для сортировки по приоритету), в которых нужно передавать в конструкторе направление сортировки и переопределить 
   метод compare, используя направление сортировки из конструктора. Направление сортировки можно задавать, используя `enum`.

### Дополнительное задание
В дополнение к возможным действиям задачи 1 добавьте возможность, чтобы после ввода всех "хотелок" и вывода в консоль 
всех "хотелок" в выбранной сортировке, программа предлагала и дальше отсортировать уже созданный список "хотелок", 
как в пункте 4. Это можно реализовать с помощью нового объекта TreeSet с выбранным Comparator и в него добавить 
содержимое старого TreeSet с помощью метода `addAll(Collection<? extends E> c)`.
